use zhconv::{is_hans_confidence, zhconv as zhconv_plain, zhconv_mw, Variant};

use axum::{
    extract::{Path, Query},
    http::StatusCode,
    response::IntoResponse,
    routing::{get, post, Router},
};
use axum_extra::TypedHeader;
use headers::{authorization::Bearer, Authorization};
use serde::Deserialize;
use tower_service::Service;
use worker::*;

use std::env;

fn router() -> Router {
    Router::new()
        .route("/", get(doc))
        .route("/convert/:target", post(convert))
        .route("/is-hans", post(is_hans))
}

#[event(fetch)]
async fn fetch(
    req: HttpRequest,
    _env: Env,
    _ctx: Context,
) -> Result<axum::http::Response<axum::body::Body>> {
    console_error_panic_hook::set_once();
    Ok(router().call(req).await?)
}

pub async fn doc() -> &'static str {
    r#"zhconv-rs 中文简繁及地區詞轉換

REPO: https://github.com/gowee/zhconv-rs

ENDPOINTS:

1. POST /convert/{target}
   Convert Chinese text between variants
   
   Path Parameters:
   - target: Variant type (zh-{hans, hant, tw, hk, cn})
   
   Query Parameters:
   - wikitext: boolean (optional) - Set to true to handle WikiText markup
   
   Headers:
   - Authorization: Bearer token (optional unless TOKEN env var is set)
   
   Request Body:
   - Plain text to be converted
   
   Response:
   - 200: Converted text
   - 401: Unauthorized (if token validation fails)

2. POST /is-hans
   Check if text is Simplified Chinese
   
   Request Body:
   - Text to analyze
   
   Response:
   - 200: Confidence score (0.0 to 1.0, or NaN)

Examples:

   POST /convert/zh-hant
   Content: \"简体字\"
   Response: \"簡體字\"

   POST /convert/hans?wikitext=true
   Content: \"繁-{體}-字"
   Response: \"简體字\"

   POST /is-hans
   Content: \"简体字\"
   Response: \"1.0\""


(The doc is generated by Amazon Q.)
"#
}

#[derive(Deserialize)]
pub struct ConvertQuery {
    // #[serde(default = false)]
    wikitext: Option<bool>,
}

pub async fn convert(
    Path(target): Path<Variant>,
    Query(params): Query<ConvertQuery>,
    bearer: Option<TypedHeader<Authorization<Bearer>>>,
    body: String,
) -> impl IntoResponse {
    if let Ok(token) = env::var("TOKEN") {
        if bearer.as_ref().map(|b| b.token()) == Some(&token) {
            return (
                StatusCode::UNAUTHORIZED,
                String::from("Unauthorized - Token is set by the TOKEN envvar"),
            );
        }
    }
    let wikitext = params.wikitext.unwrap_or(false);
    // let target = Variant::from_str(&target).expect("Unsupported target variant");

    let response_body = if wikitext {
        zhconv_mw(&body, target)
    } else {
        zhconv_plain(&body, target)
    };

    (StatusCode::OK, response_body)
}

pub async fn is_hans(body: String) -> impl IntoResponse {
    is_hans_confidence(&body).to_string()
}
